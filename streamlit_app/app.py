"""Streamlit dashboard for reviewing Checkov scan results and generating LLM remediation suggestions."""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any, Dict, Iterable

import streamlit as st

from .llm import generate_fix_suggestion

DEFAULT_REPORT_PATH = Path(os.environ.get("CHECKOV_REPORT_PATH", "artifacts/checkov_report.json"))


def _load_report(path: Path) -> Dict[str, Any] | None:
    if not path.exists():
        return None
    try:
        with path.open("r", encoding="utf-8") as handle:
            return json.load(handle)
    except (json.JSONDecodeError, OSError) as exc:
        st.error(f"Failed to load Checkov report at {path}: {exc}")
        return None


def _extract_failed_checks(report: Dict[str, Any]) -> Iterable[Dict[str, Any]]:
    results = report.get("results", {})
    for check in results.get("failed_checks", []):
        yield check


st.set_page_config(page_title="Checkov Remediation Assistant", layout="wide")
st.title("Checkov Remediation Assistant")

st.sidebar.header("Scan Report Source")
use_default = False
if DEFAULT_REPORT_PATH.exists():
    use_default = st.sidebar.checkbox(
        f"Use default report ({DEFAULT_REPORT_PATH})",
        value=True,
        help="Load the Checkov JSON report generated by the automated scan pipeline.",
    )

uploaded_file = st.sidebar.file_uploader(
    "Upload a Checkov JSON report", type=["json"], help="Drop a report exported using `checkov --output json`."
)

report_data: Dict[str, Any] | None = None
report_source = ""

if uploaded_file is not None:
    try:
        report_data = json.load(uploaded_file)
        report_source = uploaded_file.name
    except json.JSONDecodeError as exc:
        st.error(f"Uploaded file is not valid JSON: {exc}")
elif use_default:
    report_data = _load_report(DEFAULT_REPORT_PATH)
    report_source = str(DEFAULT_REPORT_PATH)

if report_data is None:
    st.info("Upload a Checkov JSON report or enable the default report to begin.")
    st.stop()

failed_checks = list(_extract_failed_checks(report_data))

if not failed_checks:
    st.success("No failed checks found in the report! ðŸŽ‰")
    st.stop()

st.caption(f"Loaded {len(failed_checks)} failed checks from {report_source}.")

for idx, check in enumerate(failed_checks, start=1):
    with st.expander(f"{idx}. {check.get('check_name', 'Unnamed check')} ({check.get('check_id')})", expanded=False):
        resource = check.get("resource", "Unknown resource")
        file_path = check.get("file_path", "N/A")
        guideline = check.get("guideline")
        st.markdown(
            f"**Resource:** `{resource}`\n\n"
            f"**File:** `{file_path}`\n\n"
            f"**Check ID:** `{check.get('check_id')}`"
        )
        if guideline:
            st.markdown(f"**Guideline:** {guideline}")

        st.code(check.get("code_block") or "No code block available", language="text")

        if st.button("Generate fix suggestion", key=f"fix-btn-{idx}"):
            with st.spinner("Contacting language model..."):
                suggestion = generate_fix_suggestion(check)
            st.markdown("### Suggested Remediation")
            st.write(suggestion)

st.sidebar.success("Report loaded. Explore failed checks and request remediation suggestions as needed.")
